# 97layerOS 시스템 구조 및 기술 부채 분석 보고서 (2026-02-24)

## 1. 개요

현재 97layerOS는 **큐-기반 비동기 멀티-에이전트 시스템**으로 설계되어 있으며, 파일 시스템을 영속성 계층(Persistence Layer)으로 활용하는 독특한 아키텍처를 가집니다. 각 에이전트는 독립적인 루프(`AgentWatcher`)를 통해 작업을 가로채고 처리하는 탈중앙화된 구조입니다.

---

## 2. 아키텍처 핵심 구성 요소

- **Queue Manager (`queue_manager.py`)**: Redis/RabbitMQ 없이 파일 시스템과 `fcntl` 락을 이용해 원자성(Atomicity)을 보장하는 태스크 큐 구현.
- **Agent Router (`agent_router.py`)**: 키워드 및 AI 분류를 통한 에이전트 선별 및 Brand OS 디렉티브(Brand Identity) 동적 주입.
- **Pipeline Orchestrator (`pipeline_orchestrator.py`)**: `SA → AD → CE → CD` 로 이어지는 발행 체인을 자동화. 현재는 `SA` 완료 후 코퍼스 누적 위주로 동작하도록 설정됨.
- **Specialized Agents**:
  - `BrandScout`: 매거진 B 스타일의 브랜드 발굴 및 웰니스 트렌드 분석 자동화.
  - `AD/CD/CE/SA`: 각 단계별 시각/내용/전략적 분석 수행.

---

## 3. 기술 부채 및 구조적 취약점 분석

### A. 데이터 및 문서 분산 (Fragmented Metadata)

- **증상**: 브랜드 정보가 `knowledge/brands/`, 신호가 `knowledge/signals/`, 리포트가 `knowledge/reports/`에 산재함.
- **부채**: 동일한 브랜드나 주제에 대한 데이터가 여러 경로에 중복 저장되거나, 참조 관계가 명확하지 않음.
- **리스크**: 데이터 일관성 파괴 및 검색 성능 저하.

### B. 에이전트 로직 중복 및 강결합

- **증상**: `AD`, `CE`, `BrandScout` 등 여러 에이전트 내부에 Gemini API 호출, JSON 파싱, 파일 저장 로직이 중복 구현됨.
- **부채**: `PipelineOrchestrator`가 에이전트의 내부 작업 타입(`analyze_signal`, `create_visual_concept`)을 너무 상세히 알고 있음 (추상화 부족).
- **리스크**: 에이전트 인터페이스 변경 시 오케스트레이터와 함께 수정해야 하는 강결합 발생.

### C. 파일 시스템 기반 큐의 확장성 한계

- **증상**: 작업 수가 많아질 경우 `.infra/queue/` 하위 파일 수가 급증.
- **부채**: `os.listdir`이나 `glob` 연산 비용 상승.
- **리스크**: 고부하 상황에서 파일 I/O 병목 및 큐 처리 지연.

### D. 예외 처리 및 가시성 부족

- **증상**: 에이전트의 `mock_mode` 의존도가 높고, 실제 API 실패 시의 복구 로직(Retry, Circuit Breaker)이 원시적임.
- **부채**: `monitor_dashboard.py`가 존재하지만 내부 상태를 실시간으로 추적하기엔 부족함.

---

## 4. 해결을 위한 제안 (Roadmap)

### 1단계: 에이전트 공통 모듈화 (Core Refactoring)

- **작업**: 모든 에이전트가 사용하는 LLM 호출, JSON 파싱, 큐 응답 전송 로직을 `core/agents/base_agent.py`로 상속 구조화.
- **효과**: 중복 코드 60% 이상 제거 및 유지보수 단일화.

### 2단계: 메타데이터 중앙화 (Entity Centralization)

- **작업**: `knowledge/registry.json`과 같은 마스터 인덱스를 도입하여 파일 경로가 아닌 엔티티 ID(UUID) 기반의 접근 체계 구축.
- **효과**: 흩어진 문서 간의 관계(Relation)를 명확히 정의.

### 3단계: 오케스트레이션 고도화 (Decoupled Flow)

- **작업**: 오케스트레이터가 특정 작업 타입을 지칭하는 대신, 에이전트가 자신의 결과를 발행하면 관심 있는 에이전트가 이를 구독(Pub/Sub)하는 방식으로 전환.
- **효과**: 새로운 에이전트 추가 시 기존 코드 수정 불필요.

### 4단계: 시스템 가시성 강화 (Deep Observability)

- **작업**: 각 에이전트의 상태(CPU/Mem/API Latency)를 `heartbeat.py`에 더 상세히 포함하고, 에러 로그를 중앙으로 집계.

---

## 5. 결론

현재 시스템은 **"실행 가능성(Executability)"** 면에서는 매우 뛰어나지만, 수동으로 생성된 문서와 자동 생성된 로그가 뒤섞여 있어 **"관리 가능성(Manageability)"**이 급격히 저하되고 있습니다. 위 리팩토링 과정을 통해 시스템을 '에이전트들의 집합'에서 '하나의 유기적인 OS'로 진화시켜야 합니다.
